class Solution {
    public int maxProfit(int[] prices) {
        // 1.状态表示
        // 以i位置为结尾....
        // 在第i天结束以后，此时是有两种状态:买入状态和可交易状态
        // 因此，可以创建两个dp表
        // 但是，这里需要考虑交易次数，因此，创建两个二维dp表 j位置表示交易次数
        // buy[i][j]:表示第i天结束以后，交易了j次，此时处于买入状态时的最大利润
        // can[i][j]:表示第i天结束以后，交易了j次，此时处于可交易状态时的最大利润
        // 2.状态转移方程
        // 两个状态，可以画状态机
        // 当i天结束是买入，那么这个状态可以由i-1天是买入(i天啥也不干)或者i-1可交易(i买入)得到
        // buy[i][j] = max(buy[i-1][j],can[i-1][j]-prices[i])
        // 当i天结束是可交易，那么这个状态可以由i-1天是可交易(i啥也不敢)或i-1买入(i卖出)得到
        // 需要注意这里的交易次数，如果前一天是买入状态，今天卖出的话，那么交易次数多了一次
        // 所以说，前一天是买入状态时的交易次数是j-1
        // can[i][j] = max(can[i-1][j],buy[i-1][j-1]+prices[i])
        // 3.初始化
        // 状态转移方程用到了i-1  所以两个二维数组的第一行都要考虑初始化
        // 状态转移方程用到了j-1  所以第一列要考虑初始化,但是，不初始化的话，可以加一个判定条件
        // 一开始：can[i][j] = can[i-1][j]  
        //if (j-1 >= 0) 再得最大值  can[i][j] = max(can[i][j],buy[i-1][j-1]+prices[i])
        // 第一天买入，交易次数0   
        // buy[0][0] = -prices[0] 
        // buy[0][1] buy[0][2] 为负无穷大，因为，由于交易次数受限，不能在第一天交易(买入又卖出)
        // 而且，我们求的是max,为了避免影响后续结果，将buy[0][1] buy[0][2]初始化为负无穷大
        // 并且，这里由于出现了负无穷大的减法操作can[i-1][j]-prices[i] 可能出现越界
        // 因此，在平常习惯中，正无穷大使用 0x3f3f3f3f(Integer.MAX_VALUE的一半) 负无穷大加-即可
        // 同理，can[i][0] = 0 can[i][1] can[i][2]= -0x3f3f3f3f
        // 4.填表顺序
        // 从左到右 两张表一起填
        // 5.返回值
        // 最大利润必不可能是买入状态，因此到can表中找最大值
        // 由于交易次数有 0次 1次 2次，所以，遍历can表最后一行返回最大值
        
        // 创建dp表
        int INF = 0x3f3f3f3f;
        int n = prices.length;
        int[][] buy = new int[n][3];
        int[][] can = new int[n][3];
        // 初始化
        // 第一天买入
        buy[0][0] = -prices[0];
        // 不能初始化为0，因为利润可能为负数，求最大值时，就取到了0
        buy[0][1] = buy[0][2] = -INF;
        // 第一天啥也不做
        can[0][0] = 0;
        can[0][1] = can[0][2] = -INF; // 避免影响后续结果
        // 填表
        for (int i = 1; i < n;i++) {
            for (int j = 0; j < 3;j++) {
                // 第i天结束后，交易了j次，处于买入状态时的最大利润
                buy[i][j] = Math.max(buy[i-1][j],can[i-1][j]-prices[i]);
                // 第i天结束后，交易了j次，处于可交易状态时的最大利润
                can[i][j] = can[i-1][j];
                // 避免越界
                if (j-1 >= 0) {
                    can[i][j] = Math.max(can[i][j],buy[i-1][j-1]+prices[i]);
                }
            }
        }
        // 返回值
        // 遍历can表得最大值
        int ret = can[n-1][0];
        for (int j = 1; j < 3;j++) {
            ret = Math.max(ret,can[n-1][j]);
        }
        return ret;
    }
}
