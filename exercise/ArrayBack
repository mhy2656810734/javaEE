class ArrayBack {
    public int longestPalindromeSubseq(String s) {
        // 1.状态表表示
        // dp[i] 表示以i位置为结尾的所有子序列中，最长回文子序列的长度
        // 根据dp[i] 推导状态转移方程
        // 一般子序列问题，都是根据i位置元素能不能跟在 0~i-1 范围内位置的元素后面
        // 由于dp[i]仅表示长度，没有记录dp[i-1]是什么回文子序列，
        // 不能将i位置直接加到i-1后面,组成新的子序列无法确定是不是新的回文子序列
        // 因此，重新找状态表示
        // dp[i][j] 表示以i位置和j位置结尾的所有子序列中，最长回文子序列的长度
        // 2.状态转移方程
        // 先判断s[i] == s[j] 是否成立
        // 2.1成立的话
        // 判断i和j的位置关系  如果i == j dp[i][j] = 1  如果i+1 = j dp[i][j] = 2
        //             如果ij中间有很多元素：dp[i][j] = dp[i+1][j-1] +2 (2表示ij位置字符)
        // 2.2不成立的话
        // 就去(i+1,j) 和 (i,j-1) 这两个范围找最大值 dp[i][j] = max(dp[i+1][j],dp[i][j-1])

        // 3.初始化
        // 出现了 i+1 和j-1 考虑越界
        // 由于i == j 这种情况已经特殊处理了，所以用到dp表中对角线以上的元素
        // i+1最后一个位置也就是 (i,i)  i== n-1会越界，但是i == i 已经处理了
        // j-1是第一个位置也就是(i,i) i == 0   会越界，但是i == i 已经处理了
        // 所有没有越界问题
        // 4.填表顺序
        // 出现了i+1 j-1 从下往上填 从左到右填
        // 5.返回值
        // dp[0][n-1]

        // 创建dp表
        int n = s.length();
        
        int[][] dp = new int[n][n];
        // 填表
        for (int i = n-1; i >= 0;i--) {// 固定开始范围
            for (int j = i; j < n;j++) {// 枚举结束范围
            // 先判断字符相等是否成立
                if (s.charAt(i) == s.charAt(j)) {
                    if (i == j) {
                        dp[i][j] = 1; 
                    } else if (i+1 == j) {
                        dp[i][j] = 2;
                    } else {
                        dp[i][j] = dp[i+1][j-1] + 2;
                    }
                } else {
                    dp[i][j] = Math.max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }
        return dp[0][n-1];
    }
}
